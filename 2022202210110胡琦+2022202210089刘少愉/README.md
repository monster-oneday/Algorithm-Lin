## 代码描述：

### 代码结构

\_cargo与\_container分别用于组织货物和容器的相关类代码，drawer用于组织绘制 3D 效果图的相关函数代码。\_init_部分用于初始化包并组织算法代码和可变策略类。

### 类设计

##### 货物 Cargo 类及其相关类

在Cargo类中描述三维状态，首先需要建立坐标系，设置三维点Point类，在类中设置合法性属性和序列化属性。

直观地描述货物的六种摆放方式，由于放入货物时，货物的重心非常重要，以货物的高将摆放方式分为三类。在高确定的情况下，将货物根据从前面观察的宽窄分为两类。将六种情况根据上述分类命名后设计为枚举类：

[![wps1.jpg](https://i.postimg.cc/zv2ZL1wM/wps1.jpg)](https://postimg.cc/30Gb6VcC) 

货物的长宽高不仅由货物的尺寸决定，还根据货物的摆放方式决定，故分别设置长宽高属性，根据其摆放方式返回正确的值。

碰撞检测中还会用到投影信息，设置投影方法，需要传入目标投影面参数：

[![wps2.jpg](https://i.postimg.cc/ZKgz445v/wps2.jpg)](https://postimg.cc/mtQ5SxMT)

 

##### 容器 Container 类

容器初始化需要长宽高信息。长宽高、提及等信息单独设置为只读属性。可放置点表需要需要按照 y 、 x 、 z的顺序排列，在容器类中使用以下方法实现：[![wps3.jpg](https://i.postimg.cc/DZ5RDKNZ/wps3.jpg)](https://postimg.cc/BLLhLR49)

判断一个货物是否在一个点上可放置，需要满足以下两个条件：

1. 不与容器内任一一个其他货物位置相冲突；

2. 完全在容器内。

对于第 1 个条件，在当前模块中以“碰撞检测”的思想实现

[![wps4.jpg](https://i.postimg.cc/J7695MJY/wps4.jpg)](https://postimg.cc/Cd8PFycb) 

挪动货物完成后，再将最终的放置点赋值回需要挪动的货物：

[![wps5.jpg](https://i.postimg.cc/DzTDwZk0/wps5.jpg)](https://postimg.cc/gxg4MG0b) 

除此之外Container类中还实现了单装箱逻辑。

##### Init_模块

用户通过继承策略 Strategy 类，重写两个静态方法，实现自定义两个装载策略：装箱顺序和货物摆放方式。然后就是进行装箱的实现，并输出货物的摆放方式、放置位置以及容器的空间利用率等信息。

##### Drawer类

进行容器中各个货物的位置和形态数据和三维可视化示意图。具体可视化时，首先初始化可视化配置，然后根据容器尺寸调整坐标轴显示比例。绘制出容器线框后，遍历容器中已放置的货物逐一绘制。

 

## 算法设计思路与流程：

### 假设与约束：

1. 货物可向上码放；

2. 货物必须完全包含在容器中；

3. 任意两个货物内的任意一点不可在空间中的同一位置；

4. 货物不可悬空放置，即货物下方必须有其他货物或容器底部支撑；

5. 货物与容器平行放置，即货物的边与容器的对应边平行；

6. 货物各个面都可以朝下放置，没有上下左右前后的区别。

### 输入输出：

输入：依次输入各个货物的长宽高和数量数据。

输出：

当每输入一个货物时，输出为：

1. 该箱子的放置位置；

2. 该箱子的摆放状态；

3. 箱子调整到摆放状态所对应的长宽高；

4. 目前容器的占用率。

当所有箱子都输入完成后，输出为：

1. 容器最终的利用率；

2. 结果示意图。

### 算法设计：

在三维装箱过程中，在水平和垂直方向上同时引入参考砖来引导装填过程。本算法使用记录可放置点的方法来查找装填位置，引入水平参考面和垂直参考面来引导装填过程。

##### 可放置点

可放置点指的是在向容器装入一个货物时，可以用来参考货物放置位置的点。可放置点以有序列表的形式存储在容器的数据结构中，称为可放置点表。

虽然这个点称作可放置点，但在放置之前仍然需要检测放入的货物是否满足上述的约束条件。在初始的容器中，只有一个可放置点，即原点 ( 0 , 0 , 0 ) 。在放入货物 j 后，就需要更新可放置点：将货物 j 放置时参考的可放置点从可放置点表中删除，然后再将新的可放置点添加到可放置点表中。新加的可放置点分别为货物 j 前、上、右边的点，即 ( x j + l j , y j , z j )、 ( x j , y j + w j , z j )、 ( x j , y j , z j + h j )。如图所示，可放置点在图中加粗：



[![wps6.jpg](https://i.postimg.cc/3Rrc2cwH/wps6.jpg)](https://postimg.cc/rdbjkgWh) 

##### 参考面

容器内是一个三维空间，使用两个参考面作为限制，将三维装箱问题分治为一个维度。设置 x 与 z轴上两个参考面 P h 和 P v，它们分别与 x y面平行 x y，在考虑将一个货物装入容器时，除了需要满足上述的约束条件（除约束 4），还需要满足摆放后不能超过参考面。故放置货物时选择可放置点的顺序应先从 y方向选择，再考虑 x和 z方向。这个选择方式与“可放置点”一节中对可放置点表的排序相吻合。

初始状态下， P h 和 P v 的值均为 0。当一个货物装入容器但不满足参考面限制时，需要调整参考面的值，然后再重新装入货物。如果调整参考面后依然无法放置，则认为该货物在当前容器状态下无法置入，考虑下一个货物。

##### 挪动

根据经验放置的箱子靠边时，才能放入更多的箱子。上述的所有算法步骤中均没有考虑到约束 4 的限制。为了考虑约束 4 并进一步提高空间利用率，需要在算法中增加挪动这一步骤。在使用参考面引导货物载入时，特别是在先装入小尺寸货物，再装入大尺寸货物时，会出现货物悬空，没有贴边放置，留有空隙的情况。为了消除空隙，需要考虑挪动货物，将货物尽量靠边。

在容器中挪动货物有向左 y 、向后 x 、向下 z三个方向。为了保证最终货物不是悬空的，即满足约束 4，须在向左 y 、向后 x 调整了货物位置后，再调整垂直 z 方向上的位置。挪动的结果是将货物尽量靠边，所谓尽量，是指货物挪动前后要满足约束和假设。

#####  每个物体的决策时间

在每个物体摆放开始时，使用time.time()函数返回当前时间的[时间戳](https://so.csdn.net/so/search?q=时间戳&spm=1001.2101.3001.7020)：

[![wps7.jpg](https://i.postimg.cc/8k00rwQq/wps7.jpg)](https://postimg.cc/kDWc0Q5c) 

在物品摆放结束时，同样使用time.time()函数返回当前时间的[时间戳](https://so.csdn.net/so/search?q=时间戳&spm=1001.2101.3001.7020)，并通过time.time()返回的时间戳做差值，可以计算一个程序运行的秒差，及计算一个物品摆放位置的花费时间：[![wps8.jpg](https://i.postimg.cc/2S4cMDbD/wps8.jpg)](https://postimg.cc/bZw9S49C)

###### 结果展示：

输入：

//E1-1

C (587 233 220)

B [(108 76 30 40), (110 43 25 33), (92 81 55 39)]

输出每个物品的放置位置、摆放状态、箱子调整到摆放状态所对应的长宽高、目前容器的占用率、花费时间。

[![wps9.jpg](https://i.postimg.cc/4dFBV4Mz/wps9.jpg)](https://postimg.cc/BLHTG3J6) 
