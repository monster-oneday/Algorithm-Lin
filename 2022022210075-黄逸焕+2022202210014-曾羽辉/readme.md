# 一、问题描述

物流公司在流通过程中，需要将打包完毕的箱子装入到一个货车的车厢中，为了提高物流效率，需要将车厢尽量填满，显然，车厢如果能被100%填满是最优的，但通常认为，车厢能够填满85%，可认为装箱是比较优化的。
设车厢为长方形，其长宽高分别为L，W，H；共有n个箱子，箱子也为长方形，第i个箱子的长宽高为li，wi，hi（n个箱子的体积总和是要远远大于车厢的体积），做以下假设和要求：

1. 长方形的车厢共有8个角，并设靠近驾驶室并位于下端的一个角的坐标为（0,0,0），车厢共6个面，其中长的4个面，以及靠近驾驶室的面是封闭的，只有一个面是开着的，用于工人搬运箱子；
2. 需要计算出每个箱子在车厢中的坐标，即每个箱子摆放后，其和车厢坐标为（0,0,0）的角相对应的角在车厢中的坐标，并计算车厢的填充率。

# 二、具体问题

1. 静态装箱，即从n个箱子中选取m个箱子，并实现m个箱子在车厢中的摆放（无需考虑装箱的顺序，即不需要考虑箱子从内向外，从下向上这种在车厢中的装箱顺序）

2. 参数考虑小数

3. 所有的箱子全部平放，即箱子的最大面朝下摆放

4. 考虑所有箱子禁止悬空，因此箱子底部必须被全部覆盖（既支撑物的上表面积大于所放箱子的底面积）

# 三、约束条件

1. 箱子必须在车厢内（不能超过车厢容纳范围）。

2. 任何两个箱子不能重叠。

3. 所有箱子只能沿x、y、z轴放，不能斜放。

4. 箱子底部必须有支撑，箱子底部必须被全部覆盖

# 四、目标

车厢体积为V，所有装入的箱子总体积为S。问题的目标是要确定一个可行的箱子放置方案使得在满足给定装载约束的情况下，填充率尽可能的大，这里填充率指的是
`S / V ∗ 100%`

# 五、设计思路

## 1、问题建模

## 1.1、对车厢、箱子和剩余空间建模

首先对车箱的长宽高分别建立坐标轴：x、y、z。令三维坐标轴的原点为箱子的左后下角，此点的坐标为（0，0，0）。
箱子的装载是在剩余空间中进行的，剩余空间是车厢中的未填充长方体空间，lx、ly、lz描述了它在3个维度上的长度。
箱子是问题中被装载的物体，同样用lx,ly,lz三个域来描述它3条边的长度。
综上，我们可以使用一个三元组 (container,box_list,num_list)来表示该问题，其中container是初始剩余空间，box_lis是一个箱子向量，指定可用于装载的箱子， num_list则是一个整数向量，描述了每一种类型箱子的数目。

## 1.2、箱子组合建模

我们定义包含许多箱子的长方体为block。block结构用lx,ly,lz描述三条边的长，volume描述其中箱子的总体积，整数向量require_list 描述了block对各种类型箱子的需求数。由于block中有空隙，block的顶部有一部分可能由于失去支撑而不能继续放置其它块，我们通过可行放置矩形来描述block的顶部可以继续放置其它block的矩形区域。这里我们仅考虑包括block顶部左后上角的可行放置矩形，以block结构的域ax,ay 表示其长宽。block表block_table 是预先生成的按block体积降序排列的所有可能block的列表，用于迅速生成指定剩余空间的可行block列表。同时，block表将block生成算法与装载算法分开，使得更换block生成算法变得容易。

## 1.3、剩余空间和剩余箱子建模

在基础启发式算法中，剩余空间被组织成堆栈。算法基本过程可描述为：从栈顶取一个剩余空间，若有可行块，按照装载序列选择一个块放置在该空间，将未填充空间切割成新的剩余空间加入堆栈，若无可行块则抛弃此剩余空间，如此反复直至堆栈为空。在此过程中， pace_stack 表示剩余空间堆栈，整数向量 avail_list 记录各种剩余箱子的数目。

## 1.4、摆放动作建模

箱子的摆放表示为一个剩余空间和块的二元组。例如 (space,block) 表示将block 放置在剩余空间space 上。放置是通过将block的参考点和剩余空间的参考点重合得到的。

## 2、block的生成

### 2.1、简单block

即相同类型的箱子进行堆叠。其中可向x、y、z三个方向进行堆叠。

### 2.2、复合block

即不同简单block的堆叠复合。
同时考虑到约束以及防止维度爆炸需要对复合block进行如下的限制：
(1) 复合block的大小不大于容器的大小。
(2) 复合block中可以有空隙，但它的填充率至少要达到 MIN_FILL_RATE 。
(3) 受复合block中空隙的影响，复合block顶部有支撑的可行放置矩形可能很小，为了进一步的装载，我们限定可行放置矩形与相应的复合block顶部面积的比至少要达到 MIN_AREA_RATE。
(4) 为控制复合block的复杂程度，定义复合block的复杂度如下：
简单block的复杂度为0，其它复合block的复杂度为其子block的复杂度的最大值加1。block结构的 times 域描述了复合block的复杂程度，我们限制生成block的最大复杂次数为 MAX_TIMES 。
(5) 按x轴方向、按y轴方向复合的时候，子block要保证顶部可行放置矩形也能进行复合。在按 z轴方向复合时，子block要保证复合满足约束4。
(6) 拥有相同3边长度、箱子需求和顶部可行放置矩形的复合block被视为等价块，重复生成的等价block将被忽略。
(7) 在满足以上约束的情况下，block数目仍然可能会很大，我们的生成算法将在block数目达到MaxBlocks 时停止生成。

## 3、可行block生成

可行block生成算法gen_block_list(space,avail,block_table) 用于从block_table 中获取适合当前剩余空间的可行block列表。该算法扫描 block_table ，返回所有能放入剩余空间 space 并且 avail 有足够剩余箱子满足require 的block。由于block_table 是按block中箱子总体积降序排列的，返回的 block_list 也是按箱子总体积降序排列的。

## 4、剩余空间更新

在每个装载阶段一个剩余空间被装载，装载分为两种情况：有可行block，无可行block。在有可行block时，算法按照块选择算法选择可行block，然后将未填充空间切割成新的剩余空间。在无可行block时，当前剩余空间被抛弃，若其中的一部分空间可以被并入当前堆栈中的其他空间，则进行空间转移重新利用这些空间。

## 5、启发函数

我们使用补全算法当作启发函数。评估当前的部分放置方案好坏的最直接的方法是用某种方式补全它，并以最终结果的填充率作为当前状态的评估值。在每个装载阶段算法都选择可行块列表中体积最大的块进行放置。算法不改变输入的部分放置方案，只是把最终补全的结果记录在此状态的volume_complete 域作为该状态的评估值。

## 6、深度优先搜索算法

由于搜索过程中，每一个节点都有大量分支，采用宽度优先搜索需要海量的空间，因此是不现实的。因此我们采取带深度限制的深度优先搜索算法，通过深度来限制最多放置的块的数目。具体来说，我们使用深度搜索扩展当前放置方案，然后在叶子节点使用补全算法来评估叶节点的好坏，最终以搜索树中最好的一个叶子节点的评估值作为当前状态的评估。另外，由于每个阶段可行块列表包含大量的块，算法往往也限制每个节点的最大分支数。我们采用深度优先搜索算法扩展当前放置方案，算法的输入为一个部分放置方案，深度限制和最大分支数。该算法从一个部分放置方案出发，递归的尝试可行块列表中的块，在到达深度限制的时候调用补全函数得到当前方案的评估值，并记录整个搜索过程找到的最优的评估值作为输入部分放置方案的评估。搜索深度代表通过深度优先搜索放置的块的最大个数。

# 六、算法流程

![1 ](https://s2.loli.net/2023/01/10/jnHc71kYZvxouwI.png)

# 七、代码描述

## 1、运行环境

python3.6 + numpy + matplotlib

## 2、 运行方式

`python pd.py`

## 3、代码描述

### 3.1、`main()`函数

定义车厢的大小以及每种箱子的大小、数量，接下来运行`run_solution()`

### 3.2、`run_solution()`函数

读取车厢大小和箱子信息，转到`basic_heuristic()`进行求解

### 3.3、`basic_heuristic()`函数

首先生成复合block:`gen_complex_block()`和简单block:`gen_simple_block()`。

随后初始化状态，包括已生成的装箱方案列表、剩余空间、剩余可用的箱子数量以及已经装载箱子的总体积、最终装载箱子的总体积的评估值。

进行循环直到剩余空间全部占满：

    生成可行block列表`gen_block_list()`   。

    如果生成列表不为空：

        找到下一个近似最优块：`find_next_block()`

        弹出栈顶剩余空间
        更新可用的箱子的数量
        更新放置计划
        更新已经利用的体积
        压入更新的剩余空间：`gen_residual_space()`
    否则：
        转移剩余空间`transfer_space()`

最后打印结果，包含剩余的箱子数量以及车厢的利用率。                

### 3.4、`gen_simple_block()`函数

生成简单block，同时定义生成的block中的各个属性：所需箱子数量、长、宽、高、体积、顶部可放置矩形尺寸、block的复杂度

### 3.5、`gen_complex_block()`函数

生成复合block，首先生成简单block，再对简单block按照x、y、z三个方向进行复合。同时定义生成的block中的各个属性：所需箱子数量、长、宽、高、体积、顶部可放置矩形尺寸、合并方向、子block列表、block的复杂度。最后需要按照填充体积对复合块进行排序。

### 3.6、`gen_block_list()`函数

生成可行block列表，包含以下约束：

- block中需要的箱子需求数量必须小于当前待装箱的箱子数量

- block的尺寸必须小于放置空间尺寸

### 3.7、`place_block()`函数

block放置算法。

提取栈顶剩余空间。随后更新可用的箱子的数目、更新放置状态、更新体积、得到新的剩余空间   `gen_residual_space()`，最后返回本次临时生成的放置。

### 3.8、 `gen_residual_space()`函数

裁剪出新的剩余空间，首先计算出新的剩余空间。随后将新裁剪出的剩余空间按照三个维度的剩余空间大小进行转移，即如果x轴的尺寸大于y轴的就将该空间归属于x轴，反之归属于y轴。

### 3.9、`transfer_space()`函数

实现剩余空间的转移。

如果仅剩一个空间的话就无法转移，直接弹出。

否则先提取带转移的空间，随后提取目标空间。将可转移的空间转移给目标空间。

### 3.10、`find_next_block()`函数

寻找下一个可行的block

首先初始化最优适应度为0，将最优block初始化为第一个block。

随后遍历所有可行block列表：
    取出栈顶空间
    放置block：`place_block()`函数
    评估：`estimate()`函数
    随后移除刚刚放置的block（回溯）：`remove_block()`函数
    如果该方案比最优解好，就更新最优解。
最后返回最优的放置block

### 3.11、`estimate()`函数

评价某个块

使用深度优先搜索：`depth_first_search()`

返回评估值

### 3.12、`remove_block()`函数

block移除算法

还原以下信息：可用箱体数目、排样计划、体积利用率、剩余空间。

### 3.13、`depth_first_search()`函数

带深度限制的深度优先算法

在深度限制范围内：
    取出栈顶空间
    生成可行block列表
    如果列表不为空：
        遍历所有分支：
            放置block：`place_block()`函数
            放置下一个block：`depth_first_search()`函数
            移除刚刚添加的block：`remove_block()`函数
    否则：
        转移空间：`transfer_space()`函数
        如果成功转移：
            放置下一个block：`depth_first_search()`函数
            还原转移的空间：`transfer_space()`函数

否则：

    补全该方案，即将可行block列表的第一个放入当作补全

    更新最优解

# 八、运行结果

以下是对测试数据的实验结果：

![](https://s2.loli.net/2023/01/10/jsWdIRoZOP5y7nf.png)

上图是第一条数据装载的绘图。
以下是对所有测试数据的运行结果：
![](https://s2.loli.net/2023/01/10/DuiPV95RJzCfKS6.png)

![](https://s2.loli.net/2023/01/10/4u7qe2vDLkBFaZW.png)

![](https://s2.loli.net/2023/01/10/WEupbTty2P3KUVX.png)

![](https://s2.loli.net/2023/01/10/MA5XmgCt1nbQF8P.png)

![](https://s2.loli.net/2023/01/10/zflPec9Mqk7Ghtd.png)
